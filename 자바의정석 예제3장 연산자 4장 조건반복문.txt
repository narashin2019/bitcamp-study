자바의 정석 예제 chapter 3 연산자

[3-1]
System.out.println(++c) // 답 B

단항연산자인 은 이항연산자와 달리 보다 작은 타입도 형변환을 하지 않는다.***
이항 연산자는 연산을 위해 '피연산자 스택' 을 사용하는데 이 과정에서 
형변환이 발생하는 것이다.
반면에 단항연산자인 증가연산자 은 피연산자 스택 을 사용하지 않으므로 형변환도 발생하지 않는다.
그래서 println은 변수 c를 숫자(int)로 출력하는 것이 아니라 문자로 출력한다.
변수 c에 저장된 문자가 'A' (실제로 저장된 것은  'A' 의 문자코드인 65)이므로 
문자코드의 값이 1 증가되어 66('B'의 문자코드)이 변수 c에 저장된다. 변
수 c에 저장된 것은 문자코드 즉 정수값이다. println 은 이 값을 타입에 따라 어떻게 출력할지를 결정한다.
만일 문자타입이면 저장된 값 (문자코드) 에 해당하는 문자를 출력하고 숫자라면 숫자로 출력한다.

[3-2]
(numOfApple+9) / sizeOfBucket 이렇게 했는데 틀린건가염...


[3-7]
저는 (int)((5/9f * (fahrenheit - 32))*1000 + 5) / 1000으로 했는데 /1000f로 나눠야 하는 거였습니다..


[3-8]
boolean result = d==f2; → boolean result = (float)d==f2;

비교연산자도 이항연산자이므로 연산 시에 두 피연산자의 타입을 맞추기 위해 형변환이 발생한다
그래서 double과 float의 연산은 d과 d의 연산으로 자동형변환 되는데,
실수는 정수와 달리 근사값으로 표현을 하기 때문에 f을 d로 형변환했을 때 오차가 발생할 수 있다.***
 그래서 f값을 d로 형변환하기 보다는,
값을 유효자리수가 적은 float 로 형변환해서 비교하는 것이 정확한 결과를 얻는다.****




=====================
자바의 정석 예제 chapter 4 조건반복문


[4-1]

2번) char형 변수 가 공백이나 탭이 아닐 때 true인 조건식 
!(ch == ' ' || ch =='\t')  or  ch!=' ' && ch !='\t'


[4-3]
sum, totalsum 변수를 2개 둘어서 푼다*****

[4-4]
와.. 해설 읽고 겨우 이해함. 이걸 내머리로 풀라고...? 띠용

[4-10]
while(num > 0) {
 sum += num%10; 
 num /= 10; 
}

해설은 이해가 가는데 식이 이해가 안가요...







