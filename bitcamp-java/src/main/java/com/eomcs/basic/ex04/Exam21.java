package com.eomcs.basic.ex04;

//# 정수 변수 - 변수의 메모리 크기
// 
public class Exam21 {
  public static void main(String[] args) {
    // 정수 변수 - 메모리 크기
    
    //1바이트 0000 0000 ~ 11111 1111 = 00 ~ ff = 0 ~ 255 => -128 ~ 127
    byte b; 
    b = -128;
    b= 127;

    //b = 128; // 오류
    //b = - 129; // 오류 error: incompatible types: possible lossy conversion from int to byte

    // 2바이트 메모리 : -32768 ~ + 32767
    short s;
    s = -32768;
    s = 32767;

    //s = -32769; // 오류
    //s = 32768; // 오류

    // 4바이트 메모리 : 약 - 21억 ~ + 21억
    int i;
    i = -21_0000_0000;
    i = 21_0000_0000;

    //i = -22_0000_0000; //오류  error: integer number too large
    //i = 22_0000_0000;  //오류

    // 8바이트 메모리 약 -922경 ~ 922경
    long l;
    l = 922_0000_0000_0000_0000L;
    l = -922_0000_0000_0000_0000L;

    //l = 923_0000_0000_0000_0000L; // 오류. 922경 넘는 수는 빅인티저 빅롱 등 문자열로 다뤄야함
    //l = -923_0000_0000_0000_0000L; //


  }
}

/*
같은 숫자라도 바이트 메모리는 다를 수 있다.
ex. 시험점수니까 byte타입으로 할께요
-> cpu는 기본 64비트 씨피유에 데이터 집어넣을 때 1바이트를 넣으나 4바이트를 넣으나 8바이트를 넣으나 똑같아.
데이터를 다룰 때 무조건 64비트로 다룸. 
메모리를 아끼려고 1바이트 짜리 쓸 수 있으나 실행 속도는 64비트로 똑같음
그냥 int 써
배열을 쓸 때는 메모리가 줄 수 있으나 단타성 변수는 별 의미 없다.
자바는 숫자를 다룰 때 4바이트 32비트 씀
실무에서는 보통 걍 int 씀.
자바는 정수 연산을 4바이트로 처리함


    // 1바이트 크기의 정수 값을 담을 메모리 준비
    byte b;
  
    // 값을 메모리에 저장하려면 1과 0, 2진수 형태로 바꿔야 한다.
    // 정수를 2진수로 바꿀 때 '2의 보수' 방식을 사용한다.  
    // 1 byte(8 bit)에 저장할 수 있는 최대/최소값은 다음과 같다. 
    b = -128; // 10000000
    b = 127;  // 01111111
  
    // 다음과 같이 메모리 크기를 벗어난 값을 저장하려 하면 컴파일 오류가 발생한다.
    //b = -129; // 컴파일 오류! 
    //b = 128; // 컴파일 오류!

    // 2바이트 크기의 정수 값을 담을 메모리 준비
    short s;
    
    // 2바이트 메모리에 담을 수 있는 최소/최대 정수값
    s = -32768; // 10000000 00000000
    s = 32767;  // 01111111 11111111

    // 2바이트 범위를 벗어나면 컴파일 오류!
    //s = -32769; // 컴파일 오류!
    //s = 32768; // 컴파일 오류!

    // 4바이트 크기의 정수 값을 담을 메모리 준비
    int i;

    // 4바이트 메모리에 담을 수 있는 최소/최대 정수값
    i = -2147483648; // 10000000 00000000 00000000 00000000
    i = 2147483647;  // 01111111 11111111 11111111 11111111

    // 다음은 값을 저장할 메모리의 크기 때문에 발생한 오류가 아니다.
    // 리터럴 크기의 문제다.
    // 정수 값 뒤에 L 또는 l을 붙이지 않은 리터럴은 4바이트 크기를 의미하다.
    // 그런데 4바이트를 넘어서는 값을 리터럴로 표현했기 때문에 오류가 발생한 것이다.
    //i = -2147483649; // 컴파일 오류!
    //i = 2147483648; // 컴파일 오류!

    // 해결책?
    // - 4 byte 크기를 벗어나는 정수를 표기할 때는 반드시 숫자 뒤에 L 또는 l을 붙여야 한다.
    //i = -2147483649L; // 컴파일 오류가 발생하는 이유? 메모리의 크기가 4바이트라서 값을 저장할 수 없다.
    //i = 2147483648L;  // 컴파일 오류!

    // 8바이트 크기의 정수 값을 담을 메모리 준비 
    long l;
    
    // 8바이트 메모리에 담을 수 있는 최소/최대 정수값
    l = -9223372036854775808L; // 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 
    l = 9223372036854775807L;  // 01111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 
 

*/