200206 목요일

<중간점검_비트캠프티처에 있는 ClassDiagram>

07.
클래스 문법 사용 : 사용자 정의 데이터 타입
Lesson, Member, Board 3개의 클래스 정의. 
한 식판 단위로.
데이터 메모리 구조를 설계하는 용도

08~09.
if else문 사용

10.
App클래스가 너무 늘어나서 수업관리/ 멤버관리/ 게시물관리로 쪼갬.
수업관련 메소드는 레슨핸들러로
회원관련 메소드는 멤머핸들러로
보드관련 메소드는 보드핸들러로.

* 클래스 문법 사용 2가지:
-사용자 정의 데이터 타입 만들 때 (레슨, 멤버, 보드)
-서로 관련된 메소드들을 유지보수하기 좋도록 묶어 놓을 떄 (~Handler)

11.
한 패키지에 들어있던 것을 각각 다른 패키지로 분류를 함.
파일을 폴더로 나누어 관리하듯이

12. 
Board를 더 만들고 싶으면 BoardHandler2, 3...이렇게 추가함.
단점: Board에 기능 추가 시 각각 Handler마다 다 추가해야함.
스태틱필드, 스태틱메소드 상태
객체지향은 유지보수를 쉽게 하기 위해 코드를 쪼개는 것.

13~15.
Handler안에 인스턴스 필드, 인스턴스 메서드로.
인스턴스 필드가 됨. 
클래스는 1개로 데이터를 저장하는 필드는 인스턴스로 여러 개 생성 가능.

16.
핸들러에서 데이터를 다루는 코드를 분리시켜서 레슨리스트/멤버리스트/보드리스트 로 만듬
사용자 입력을 처리하는 부분(핸들러)과 / 데이터를 처리하는 부분(리스트)을 별도로 분리.

17.
어레이리스트 만들고 제네릭 적용.
레슨, 멤버, 보드리스트 코드가 거의 똑같고 기능이 같다. 다만 다루는 데이터만 다름.
=> 하나로 합쳐 어레이리스트만들고 제네릭을 적용해서 레슨, 멤버, 보드 나눠지도록 함.

20.
어레이리스트는 내부적으로 배열을 다루는데 
배열은 사이즈가 고정.
배열이 꽉 차거나 사이즈를 늘리고 싶으면 
더 큰 새 배열을 만들어서 기존 배열을 복사함.
기존 배열은 가비지가 됨. 
=> 링크드리스트 사용.
데이터를 생성할 때마다 node라는 데이터 담는 바구니 만들고 거기에 데이터 담고 바구니를 연결.
데이터를 담고 있는 node들을 연결해서 관리함.
배열과 다르게 사이즈가 고정되어 있지 않아
데이터를 계속 담을 수 있음.

단, 어레이리스트는 데이터를 찾을 때, 배열의 몇번 방인지 바로 찾을 수 있지만
링크드리스트는 연결고리를 계속 따라가서 찾아야함. 
100째 데이터라면 100번 연결 따라가야 찾을 수 있음.
추가 삭제는 빠르나 찾는 속도는 느림.

자료구조: 데이터가 어떤 방식으로 저장되고 관리되는 지.
스택과 큐가 프로그램에 필요해서 만든게 아니라 
배우려고 적용

21.
스택
push()넣고 pop()꺼내기
가장 마지막에 입력한 것 부터 순서대로 꺼냄.
라스트인 퍼스트아웃
퍼스트인 라스트아웃

프롬프트에 명령어줄 때 마다 나중에 입력한 명령부터 히스토리가 나오는 용도.

22..
큐
퍼스트인 퍼스트아웃
먼저 넣은 것 먼저 꺼낸다.
history2하면 이제까지 입력한 명령어 순서대로 출력.
offer() 넣기 / poll()꺼내기

23_1.
Generalization
어레이리스트와 링크드리스트의 공통점을 뽑아
추상클래스로 만들고 이름에 명시
AbstractList

제네럴라이제이션한 클래스는 그 자체로 사용하면 안된다.
그래서 그 자체를 쓰지 못하게 추상클래스로 만든다.
추상클래스는 서브클래스에게 공통 필드나 메서드를 물려주기 위한 용도이다.
상속 받아서 사용해야 한다.

23_3.
인터페이스 = 사용규칙.
추상클래스말고도 규칙만 뽑아 인터페이스를 만들면 훨씬 작업이 유연하다.

추상클래스는 추상클래스의 자식만 공통필드, 메서드를 공유할 수 있지만,
인터페이스(List)는 해당 인터페이스의 사용규칙을 적용한 
어떠한 클래스라도 공통 필드, 메서드를 공유할 수 있다.
직접 클래스를 가리키는 것보다, 규칙을 가리키는게 더 유연하다.

24_1.
이터레이터

데이터를 뽑는 게 자료구조에 따라 방법이 다르다.
스택 pop()
큐 poll()
리스트 get()

즉, 호출하는 메소드가 다르다.

=> 데이터를 뽑는 걸 별도 객체로 분리한다.
데이터 뽑는 기능을 별도의 클래스로 객체화 시킨다.
대신 규칙을 일관성있게 하기위해 인터페이스를 적용한다.
hasNext() 데이터가 있는가 / next() 데이터를 꺼낸다

Iterator의 구현체 : ListIterator(리스트에서 데이터 뽑는 애), StackIterator(스택에서 데이터 뽑는 애), QueueIterator

사용규칙이 통일되었기 때문에 같은 방법으로 데이터를 뽑아낼 수 있다.

옛날에는 데이터를 직접 뽑았는데,
이제는 데이터를 뽑는 대행자를 둔다.
그 대행자는 같은 사용법으로 사용할 수 있다.
예전에는 링크드리스트, 큐, 스택에게 get poll pop으로 직접 명령했지만,
이제는 직접말하지 않고 대행자를 통해 hasNext, next라고 물어봄.
그래서 같은 방법으로 물어볼 수 있다. 

24_2.
이터레이터를 네스티드클래스로 둔다.
해당 클래스에서만 사용되는 클래스라면 그 클래스 안에 두자.
중첩클래스.
스태틱네스티드 클래스

24_3.
논스태틱네스티드, 이너클래스로 만듬

24_4.
로컬클래스로 만듬 
특정 메서드 안에서만 사용한다면 로컬클래스로 둬도 됨.

24_5. 
익명클래스.
로컬인데 이름이 없는 것.
+ 람다 문법적용까지

25.
우리가 직접 구현한 것 대신 자바가 제공하는 것으로 바꿈

새로운 명령어 추가시 App에 추가 + Handler에 그 명령어 실행할 메서드 추가
=>기존 코드를 바꾸게 됨. 위험성 높음
가능하면 기능추가시 기존 코드 손 안대는게 좋음


26~27.
커맨드 디자인 패턴
사용자 명령어 하나당 한 개의 메서드가 호출되는 구조일때
아예 이 메소드를 별개의 클래스로.
새로운 명령어 추가시 새 클래스 만들면 됨.
기존 클래스는 손 댈 필요 없음.
Handler를 쪼개버림.
다만 일관성있게 호출할 수 있도록 Command라는 인터페이스 사용규칙 정의.
App은 ~커맨드마다 다르게 명령할 필요 없이 excute()라고 명령하면 됨. 

별도의 클래스로 담아서 포장하기 = 캡슐화


28_1. 
이전까지는 메모리에 데이터를 담았고,
프로그램을 종료하면 입력한 데이터가 다 날라감.
=>데이터를 파일에 저장하는 것으로 바꿈.

파일 객체는 파일 경로? 정보를 담고
파일리더는 파일에서 데이터 읽을 때
파일롸이터는 파일에 데이터를 쓸 때

프로그램이 시작할 때 종료할때 파일에 데이터를 읽고 쓰도록 함.

28_2.
csv = 콤마세퍼레이트밸류 
valueOf(): 콤마로 구분된 값을 주면 객체로 리턴하는 스태틱 메서드
toCsvString(): 콤마 문자열로 리턴해주는 메서드
위 두 기능을 app이 아니라 보드, 레슨, 멤버가 하게 함.

28_3.
csv방식의 문제점: 제목에 콤마가 들어간다면?
Gson
자바스크립트 오브젝트 노테이션 = JSON = 자바스크립트 객체 표기법 형식으로 
외부라이브러리 도입해서 입출력 처리


28_4.
입출력 속도를 높이기 위해 버퍼를 추가. 
파일리더, 파일라이터에 버퍼 기능을 하는 데코레이터 추가


29.
바이너리 형식으로 출력할 수 있다.
파일 인풋스트림, 파일 아웃풋스트림
+ 버퍼를 붙임
+인트 문자열 불린.. 단위로 = 데이터인풋/아웃풋스트림


30. 
시리얼라이저블 인터페이스
객체 단위로 쓰면 안되겠냐.
데이터인풋/아웃풋스트림은 낱개로 인트, 불린, ... 출력함.
오브젝트인풋/아웃풋스트림은 객체를 롸이트, 리드 오브젝트함. 
얘네도 시리얼라이즈드함. 
+보드,레슨, 멤버가 시리얼라이저블인터페이스를 구현하도록 함.

31_1
옵저버

프로그램을 시작할 때 데이터를 로딩하고
프로그램을 종료할 때 데이터를 저장하는데 

데이터 로딩, 저장 뿐만 아니라
프로그램 시작, 종료 시 뭔가 다른 기능을 추가하고 싶다. 
=> 옵저버 디자인 패턴 적용 

어떤 객체가 특정 상태에 놓였을 때 자동으로 그 기능을 수행하게 하는 방법.

먼저 옵저버호출규칙을 정한다.
옵저버를 등록하는 addApplicationContextListener() 제거하는 remove~() 메서드.
App시작시 옵저버를 호출하고 종료할 때 옵저버를 호출하는 메서드 만듬

31_2
옵저버 호출규칙에 따라
어플리케이션을 시작할떄  데이터를 로딩하고
종료할 때 데이터를 저장하는 
그런 기능을 가진 옵저버 구현체 = 데이터로더리스너

옵저버와 app사이의 데이터를 공유하는 Map
= 어플리케이션을 실행하는 동안 데이터를 보관하는 임시 보관소를
컨텍스트로 만들고 그것을 파라미터로 주고받음.


31_3

프로그램 시작 종료 시 인사하는 애 추가
옵저버구현체 추가하는법
=> 어플리케이션컨텍스트리스너 호출규칙에 따라 클래스만 구현하면됨.

=======================================

프로그램 구조를 파아갛는게 제일 중요
teacher main에 올려놓음

===========================================

32_7 서버
백업다시.Object로 이름 바꿈


============================================


(사진)
서브 클래스의 공통점을 뽑아 위로 올라가는 제너럴라이제이션

보드giledao 멤버filedoa 레슨filedao

=> (앱스트랙트)AbstractFileDao loadData() saveData() indexOf() 3개 똑같아.
제너럴 라이젼하는 클래스는 서브클래스에게 공통 코드를 주기위한 클래스라서
앱스트랙트로 정의



v32_8

READ.me 수정 제네럴라이제이션 연습 + 제네릭 적용

AbstractObjectFileDao 만듬
protected 다른패키지의 서브클래스 접근가능하도록

BoardObjectFileDao 수정
 BoardObjectFileDao 수정
MemberObjectFileDao 수정


공통점을 상속해주는 클래스는 추상클래스로
오버라이딩해야하는 메서드는 추상메서드로
제네릭 적용


=============================================
서버
v32_9 파일에 데이터를 저장할 때 제이슨 형식을 사용하기.
이번에는 스페셜라이제이션을 한다.	

-json패키지추가

-AbstractJsonFileDao 추가 (복사해옴 리네임) 변경 다시 복사해올것 코드

-build.gradle 수정 : 28_3에 빌드그레이들 디펜던시 복사해옴.
-해당 프로젝트로 가서 gradle cleaneclipse 하고 gradle eclipse한다.

-boardJsonFileDao
LessonJsonFileDao
MemberJsonFileDao
추가

-datatoaderlistener : 수정 객체준비부분 LessonJsonFileDao

-ServerApp: Json으로 수정 LessonJsonFileDao

-보드리스트서블렛 변수선언과 생성자 변경.
-보드애드서블렛 변수선언과 생성자 Json으로 변경

-서블릿 변경




이제 강종해도 애드 업데이트할때 바로바로 저장됨
------------------------------------------------

# 32_10 - 인터페이스를 이용하여 DAO 호출 규칙을 통일하기 (사진)










