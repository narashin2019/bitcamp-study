191224
*리펙토링 책 먼저보고 나중에 디자인패턴 책 봐라.

-------------------------------------------------------------
* bitcampjava ex07 assingment test4, 5과제 풀이** 선생님 과정 다시복습하기

------------------------------------------------------------
* bitcamp project v11, v12 진행 -> njp tvlist도 완료

* 게시물은 중간에 게시물이 삭제되어도 번호가 바뀌면 안된다!!! 이용자가 서로 전달을 못해
삭제된 번호 빵꾸는 유지해야함. 버려. 게시물 번호는 계속 앞으로 직진만 한다. 중간에 끼는거 없다.
> 배열로 하면 배열 인덱스 번호가 땡겨짐...
> 그래서 게시물 고유번호가 필요함.

*실제로 객체의 주소가 배열에 꽂혀있음.
근데 비유적으로 배식차에 식판 자체가 꽂혀있다고 하는것.
엄밀히 말하면 식판의 주소가 배식차에 꽂혀있음.
------------------------------------------------------------------------------------
* bitcamp project v13 아직 미완성

*동일한 코드가 있다는 것은 일부를 바꿀 때 동일한 코드 각각 찾아서 전체 다 바꿔줘야함.

*복붙의 장점: 추가는 쉽다. 개발 편의성. 그러나 중복코드 양산. 
=> 기술부채

*기술부채로 인한 단점 : 기능변경, 오류 생겼을 때 유지보수가 어렵다. 
기능변경하려면 중복코드, 즉 복사한것마다 다 바꿔야함.
오류가 있다면? 중복코드, 즉 복사한것마다 다 오류 바꿔야함.

=> 기술부채의 해결 = refactoring / architecture변경(renewal)


**해결책: class 의 메소드와 변수를 다른 방법으로 관리!!!!!
=> ****변수는 개별관리 / 메서드는 공유******************

이 문법을 배우면 게시판 복붙 안해도 되고 기능바꿀때 복붙한거 다 바꿀필요도 없고!!!

**# 13 - 인스턴스 필드와 인스턴스 메서드가 필요한 이유
- 인스턴스 필드와 인스턴스 메서드를 사용할 수 있다.
- 스태틱 필드와 인스턴스 필드의 차이점과 용도를 설명할 수 있다.
- 스태틱 메서드와 인스턴스 메서드의 차이점과 용도를 설명할 수 있다.


* 로컬변수 = 메소드 안에 있는 변수

* 클래스필드 = 스태틱필드 
-static이 붙음
-클래스에 소속된 변수
-Method Area에 클래스 코드가 로딩될 때 자동 생성된다. (1개)
-한 번 생성되면 프로그램 종료때까지 유지.
-공통으로 허용할 값일 경우 클래스 필드로 선언한다.
 
* 인스턴스필드 = 논-스태틱필드
-static이 안 붙음
-인스턴스에 소속된 변수?
-new로 시작하는 명령어 실행 시 변수가 Heap에 생성됨(클래스 로딩 시 존재x)
-Heap에 여러 개 생성 가능
-개별적으로 관리되어야 하는 값일 경우 인스턴스 필드로 선언한다.
-메서드는 포함 안된다.


*클래스 메서드
-인스턴스 없이 호출하는 메서드이다.
-인스턴스를 사용하려면 파라미터를 통해 호출할 때 외부에서 받아야 한다.
-메서드에 어떤 인스턴스를 쓸지는 파라미터로 넘겨준다
- 예:  public static void addBoard(BoardHandler boardHandler) { ~~ } 
       //addBoard가 클래스필드가 아니라 클래스 메서드이기 때문에 접근 파라미터 준다. 레퍼런스변수는 소문자로.


*static없음 = 개별관리 / static있음, 메서드 = 공유

*즉 개별적으로 관리할 것은 static없는 인스턴스 필드 non-static필드로 해라 (메서드x)

**데이터는 개별로 관리하고 메서드는 공유한다 = 인스턴스 필드의 존재이유!

*회사가면 인스턴스 필드로 대부분함. 언제라도 나중에 혹시 확장할 가능성 때문에!
-----------------------------------------------------------

* 클래스의 구성원 = 클래스 멤버도 접근제어 해야한다.

public: 다른 패키지에 소속된 클래스에서 사용할 수 있다. 다 공개하지 말고 공개할 것만 공개해야함 , 공개하지 않는게 기본. 
default: 같은 패키지에 소속된 클래스끼리는 공유 가능
private: 해당 클래스 내부에서만 사용, 해당 클래스 밖에서 못씀! (따라서 지금은 붙일 데 없다)
protected: 해당 클래스 + 상속받은 자식 클래스만

---------------------------------
<접근 범위 제어>
퍼블릭 완전공개
디폴트 같은 패키지
프로텍티드 같은 패키지 + 자식 클래스
프라이빗 자기 내부 안에서만


클래스와 이름이 같고 리턴타입이 없다
Score() {}
생성자 선언: 접근범위제어만 가능

클래스라는 문법을 구성하는 원소들 = 사진.

클래스안에 클래스 선언 가능, 
