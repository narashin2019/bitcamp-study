package com.eomcs.basic.ex04;

//# 배열 - 같은 종류의 메모리를 쉽게 만드는 방법

public class Exam61 {
  public static void main(String[] args) {
    // 배열 사용 전
    int kor, eng, math, soc, mus;

    // 배열 사용 후
    // 문법
    //  메모리종류[] 메모리이름 = new 메모리종류[개수]
    //  데이터타입[] 변수명 = new 데이터타입[개수];
    int[] score = new int[5]; // OK!
    int score2[] = new int[5]; // OK! C-style. 하지마

    //배열에 값을 저장하는 방법
    score[0] = 100;
    score[1] = 90;
    score[2] = 80;
    score[3] = 70;
    score[4] = 60;

    // - 배열의 인덱스는 0부터 시작한다.
    // - 인덱스의 범위는 0 ~ (배열개수 - 1) 이다.
    //*컴파일할 때 발생하는 에러: 그나마 다행 / 실행시 발생하는 에러: 런타임 에러 
    //score[-1] = 100; // 컴파일시에러x 실행시에러뜸. runtime error!
    //score[5] = 100; // runtime error!





    // 배열 레퍼런스(배열의주소담고있는변수)와 인스턴스(값을 저장하는 메모리)를 따로 선언
    int[] arr1 = null; //null=> 주소가0, 의미는 메모리를 가리키지 않음. null안쓰면 error: variable arr1 might not have been initialized

    //arr1[0] = 100; // runtime error! 주소가 없다는 에러, java.lang.NullPointerException


    //배열 인스턴트 생성
    arr1 = new int[5];
    // arr1
    //   - 배열 메모리의 주소를 담는 변수이다.
    //   - 이렇게 메모리의 주소를 보관하는 변수를 '레퍼런스'라 부른다.
    //
    // new int[5]
    //   - new 명령은 사용할 메모리를 확보하는 명령이다.
    //   - 즉 연속된 5 개의 int 타입 메모리를 준비하라는 명령이다.
    //   - 사용할 메모리를 확보한 후 그 메모리의 찾아 갈 수 있도록 시작 주소를 리턴한다.
    //   - 이렇게 값을 저장하기 위해 확보된 메모리를 "인스턴스"라 부른다.
    //
    // new 명령은 메모리를 확보하는 명령이다.
    // - 리턴 값은 확보된 메모리의 시작 주소이다.
    arr1[0] = 100; // OK! 0=index // arr1에 저장된 주소로 찾아가서 0번째 항목에 값을 넣어라!
    arr1[1] = 100; // OK!
    // 레퍼런스(reference)란?
    // - 값이 아닌 메모리의 주소를 담는 변수.
    //
    // 인스턴스(instance)란?
    // - 값을 저장하는 메모리.


    // 배열 사용
    System.out.println(arr1[0]); //100출력
    System.out.println(arr1[1]); //100출력




    int[] arr2;

    // 배열 레퍼런스는 배열 인스턴스의 주소를 담는다.
    // 언제든 배열 인스턴스의 주소를 다른 레퍼런스에 담을 수 있다.
    arr2 = arr1; 
    // arr2와 arr1은 같은 배열 인스턴스를 가리킨다.
    // arr1에 저장된 배열 인스턴스의 주소를 담는다.
    System.out.println(arr1[0]); //100출력
    arr2[0] = 300;
    System.out.println(arr1[0]); //300출력

    // 배열 인스턴스의 각 항목은 생성되는 순간 기본 값으로 자동 초기화 된다.
    // 일반 변수는 값을 저장하지 않고 사용할 수 없다.
    // 일반 변수와 달리 new 명령으로 확보된 메모리는 종류에 상관없이 기본 값으로 자동 초기화 된다.
    // 따라서 배열 메모리 또한 생성되는 순간 기본 값으로 자동 초기화 된다.
    // 정수 배열(byte[], short[], int[], long[]) : 0
    // 부동소수점 배열(float[], double[]) : 0.0
    // 논리 배열(boolean[]) : false 
    // 문자 배열(char[]) : '\u0000'
    // 주소 변수(Object[]) : null
    //cf. 로컬변수에 값을 초기화시키지 않으면 에러뜸
    System.out.println(arr1[2]); // 0출력


    int[] arr3 = new int[3];
    arr3[0] = 30;

    arr2 = arr3;
    System.out.println(arr2[0]); // 30출력

    arr1 = arr2;
    System.out.println(arr1[0]); // 30출력

    // 그럼 arr1에 저장되었던 기존 배열 인스턴스에는 
    // 어떻게 접근하는가?
    // => 처음 생성했던 배열 인스턴스의 주소를 갖고 있는
    //    레퍼런스가 없기 때문에 접근할 수 없다.
    // => 이렇게 주소를 잃어버려 접근할 수 없는 메모리를
    //    "가비지(garbage)"라고 부른다.
    // => 가비지는 JVM 실행 중에 메모리가 부족할 때
    //    "가비지 수집기(garbage collector)"에 의해 
    //    메모리에서 해제된다.
    //    물론 JVM을 종료하면 당연히 JVM이 사용하던
    //    모든 메모리를 OS에 반납되기 때문에 
    //    가비지 또한 반납될 것이다.
    //    
    // => 전산학에서는 "가비지"를 "dangling object"라고 부른다.

    // 가비지 동작
    // 1) 메모리가 부족할 때
    // 2) CPU가 한가할 때




    // 배열 인스턴스 생성과 동시에 값 초기화 시키기
    int[] arr4 =new int[3];
    arr4[0] =100;
    arr4[1] = 90;
    arr4[3] = 80;

    // 초기화 시키는 값 개수 만큼 배열 항목이 생성된다.
    int[] arr5 = new int[] {100, 90, 80};

    // 인스턴스 생성과 동시에 값을 지정할떄는 
    // 배열 개수를 지정하면 안된다.
    //int[] arr6 = new int[3] {100, 90, 80}; // 컴파일오류

    // 배열 선언과 동시에 인스턴스를 초기화 시킬 때는
    // new int[]를 생략할 수 있다.
    int[] arr7 = {100, 90, 80}; // 많이씀

    // 그러나 배열 변수를 선언한 후 따로 초기화시킬 때는
    // new int[]를 생략할 수 없다.
    int[] arr8;
    //arr8 = {100, 90, 80}]; // 컴파일 오류
    arr8 = new int[] {100, 90, 80};



    // 프리머타입 배열얘기만 한 것.
    // 정리!
    // 1) 배열 선언 + 초기화
    //     데이터타입[] 변수명 = new 데이터타입[]{값, 값, 값};
    //     - 배열 메모리를 초기화시킬 때는 배열 개수를 지정해서는 안된다.
    //     - 배열을 초기화시키는 값의 개수 만큼 메모리가 만들어진다.
    //     - 즉 다음은 값 개수만큼 int 메모리가 3개가 생성된다.
    //       ex) int[] arr = new int[]{10, 20, 30};
    //     - 다음과 같이 new 명령을 생략할 수 있다.
    //       데이터타입[] 변수명 = {값, 값, 값};
    //       ex) int[] arr = {10, 20, 30};
    // 
    // 2) 배열 선언 후 따로 배열 초기화 문장 실행
    //     데이터타입[] 변수명;
    //     변수명 = new 데이터타입[]{값, 값, 값};
    //     ex) 
    //     int[] arr1;
    //     arr1 = new int[]{10, 20, 30}; 
    //     - 변수를 선언한 후 따로 배열을 초기화시킬 때는 
    //       new 명령을 생략할 수 없다.

  }
}

/*
 *
int a, b, c;

c=20;
b=30;
a=10;

4byte 4byte 4byte
[ a ]  [ b ]   [ c ]
[40]   [30]   [20]

같은 타입의 변수를 여러개 만들 때.
같은 데이터 타입의 메모리를 여러 개 생성(확보)할 때 사용

 *
int[] arr          = new int[3]; //int 유형의 4바이트 메모리를 연속된 메모리로 만든다
                       (data type)
배열 주소를 담는 변수 arr, 주소를 저장하는 변수 "reference"(씨: 포인터변수) int배열의 주소를 arr에 담겟다
우항에서 메모리의 주소를 리턴. 좌항에 담는다
우항: 실제 값을 저장하는 메모리 "instance"


 *8개: primative data type 8개 제외 나머지는 전부 레퍼런스!
그자체로 쓸 수 없고 주소가 담겨 있어야 쓸 수 있다.

char[] c;
Date date;
String str;
Object obt;

 *null point exception: 

Date date;
date.getYears();
=>주소가 없다!


 *JVM은 절대주소가 아닌 offset주소를 쓴다. 
(기준점으로 부터 상대적으로 얼마나 떨어져 있나)


 *
 int[] arr2 = new int[5]; 
arr1 = arr2;
//둘 다 같은 애를 가리킴
 */
