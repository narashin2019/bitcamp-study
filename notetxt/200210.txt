200210 월요일


com.eomcs.net.ex02 


ipconfig /all , -a

DNS서버주소 웹브라우저에서 주소를 치는 순간 DNS서버로 들어감 1번 > 2번 그다음에 네이버서버로 들어감
이름을 사용하려면 DNS서버가 필요 이름의 실제 ip adress 알려주는역할



인터넷이 동작하는 원리
https://parksb.github.io/article/36.html



웹브라우저구동원리
https://d2.naver.com/helloworld/59361

----------------
(그림1)
프록시서버 - 보안 / cache / other server / pcn... 

---------------
(그림2)

new ServerSocke(8888)
내부적으로 대기열을 준비 (생성자에 기본 약 50개)

c1클라이언트가 8888포트가 접속하는 순간 대기열에 기록.
c2.. "
c50 .. "
c51 timeout 1분
c1이 빠지면 대기열에서 앞으로 땡겨지고 c 51이 들어갈 수 있음
-큐방식. 

일정시간이 1분이 지나도 대기열에 못들어가면 예외발생 후 종료

--------------------
 com.eomcs.net.ex03

PrintStream = 바이트스트림 (인풋스트림, 아웃풋스트림 상속)
PrintWriter = 캐릭터스트림(리더 롸이터 상속) (내부에 미니버퍼가있어! )

의 차이 


원칙 캐릭터스트림은 flush하지 않으면 출력되지 않는다.

바이트스트림이라도 실제 데이터 주고받을때는 버퍼드인풋스트림 데코레이터 꼽아씀
그때도 flush 강제로 해야함


=> 출력하고 난다음에 걍 flush 모두 다 해버려. 실무에선 다 버퍼쓰니까
오토플러쉬쓰면 의미가 없음. 쓰지마

=====================================



// com.eomcs.net.ex04;
전화통화: stateful
연결된채로 있으면 장점 - 대화가된다. 걔!
연결된동안의 기록이 계속 있음

// stateless : 1번만. 114

// 비영속적인 것을 영속적이게 - 세션

//여기부터 복사해올 것 stateful/ stateless

=======================================

stateful2 stateless2


(그림)

stateful
s <-> c1
c2
c3


s와 c1이 연결되면 result 변수=대화를 나누는 변수 왔다갔다 끝나면 c2와 s 사이의 result 또 생기고

---

stateless
계산결과를 어떻게 유지할 것인가?

c1의 계산결과를 유지할 result 변수와
c2 계산결과를 유지할 result변수 구분해야하고/

다시 연결한 클라이언트가 어떤 변수를 이용하는 클라이언트인지 알아야함.

> 어느고객이 커피를 몇번 먹었는지 관리해야함. 단 정보는 커피숍자체에서 관리한다.
병원 어느환자가 어느병때문에 언제 방문했는지 나의 이전 방문정보를 알고있다.
병원에서는 차트에 기록
ABC환자 구분은 환자가 먼저 전화번호주민번호이름 제출
병원에서는 여러개 차트중에서 전화번호주민번호이름에 해당하는 것 찾아 의사한테 줌

> 전세계 서버가 병원과 똑같이 동작

> result차트 여러개 만들어. 서버가 관리
어떤 클라이언트인지 result차트 찾을 때 클라이언트의 식별ID로 차트를 찾음

클라이언트1이 접속. 
자신의 식별ID 보냄
연산자보냄.
값을 보냄

서버는 먼저 식별ID를 보고 차트찾음.
0번은 새로운 고객 > 차트를 만듬.4번 = 세선ID > 현재 계산 결과를 차트에 저장. 결과 클라이언트의 너 몇번이야 + 리설츠 응답. 끝



클라이언트3 접속
자신의 식별 ID3번 보냄
연산자보냄./
값을 보냄

서버는 식별ID보고 차트찾음
3번에 저장되어 이쓴 값에 연산
너의 아이디와 리졀트 같이 리턴.



영속적으로 하라고 만든애가 아니라서 영속적인 작업하라니까 이렇게 해야함.
stateless 단타성인데 stateful 처럼 영속적인 작업을 하라고 함.
stateless 대표적인 프로토콜이 HTTP이라 꼭 알아야함.
HTTP는 stateless방식.

네이버에 내가 로그인하면 로그인한 사용자 중심으로 정보를 띄움
이제 모든 작업이 내 꼬리표를 달고 작업을함.
>어떻게 관리ㅣ하길래?
>위의 방식.
> stateless2


=>
결과는 Map으로 처리 : key=clientID(세션ID) value=result로 처리

웹에서는 이걸 세션이라고 부른다

번호int 연산자 string 값int <- 주고
-> 번호int 리졀트 string 리턴

>
웹어플개발시 HTTP의 세션과 똑같이 동작함
HTTP 프로토콜은 stateless로 돌아감

내가 웹클라에서 웹서버로 요청할 때마다 세션아이디를 같이보낸다!