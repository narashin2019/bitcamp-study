200109 목요일

비트캠프 프로젝트 com.eomcs.lms.handler; public class LessonHandler

메서드: 특정기능 수행하는 것을 별도의 블럭으로 묶어서 
필요할때마다 사용.

private: 내부에서만 쓴다

리팩토링하면 소스코드가 늘어날 수 있다.
속도가 조금 느려진다.
리팩토링은 속도가 느려져도 소스코드가 가독성 높이고 유지보수하기 좋게 하는 것.
그러면 주석을 달 필요가 없다.
처음엔 리팩토링신경. 성능은 나아아중에
<-> 옵티마이징: 속도를 빠르게, 초보가 신경쓸 것 아님.
속도관리는 나중에 버벅거릴때 아래같은 걸로.
APM 어플리케이션 퍼포먼스 모니터링
APM 솔루션 - 제니퍼소프트가 유명 > 꿈의직장!


객체지향분석설계
마틴파울러책 리팩토링 꼭봐라

오버로딩 스트링인풋

체인지드 여부 뺀다 > 맨마지막에 비교하는 걸로


    System.out.print("설명? ");
    inputStr = input.nextLine();
    if (inputStr.length() == 0) {
      newLesson.setDescription(oldLesson.getDescription());
    } else {
      newLesson.setDescription(inputStr);
      changed = true;
    }

=>  newLesson.setDescription(inputString("설명(%s)? ", oldLesson.getDescription()));



      
*오브젝트로 상속받은 .equals 메소드는 사실 두개의 인스턴스(주소)를 비교함. 

    if (oldLesson.equals(newLesson)) {
      System.out.println("수업 변경이 취소되었습니다.");
      return;
    } else {
      this.lessonList.set(index, newLesson);
      System.out.println("수업을 변경했습니다.");
    }

-=> 그래서 무조건 변경 되었습니다가 실행됨

=> 인스턴스 안에 들어있는 스트링이 비교되어야함
-> 오버라이딩!! lesson에서 !! 
멤버, 레슨, 보드 우클릭 소스 이퀄있는거. 해쉬코드는 나중에 설명
---------------------------------------------------

util에 프롬프트만듬
public으로 변경 
레슨핸들러 변경


============================

이너클래스 중첩클래스
인스턴스 주소를 다루는 방법
반복문 조건문
=>링크드리스트 만드는 과정에서 프로그래밍 실력 향상됨.

어레이리스트로 링크드리스트 단계별로 타이핑할 수록 실력이 는다.

하는일은 어레이 리스트와 링크드 리스트가 같다

알고리즘은 빠르게! 풀수있을 만큼 연습해야함.
꼬아서 내기 때문. 
visualsgo.net 해봐봐 - 링크드리스트 검색
알고리즘은 풀이법 암기하는것.

절대적 코딩량을 채워야한다.
배울때는 또라이처럼
앉아서 이클립스 켜놓고 가만히 있어봐.

어레이리스트를 안보고 칠 때까지.

11qjs!!
자바.랭.리플렉트.어레이.뉴인스턴스 메서드 있음.
componentType: 배열을 구성하는 하나의 항목의 타입이 뭐냐는 질문 > E(E는 클래스를 가리키는 레퍼런스 격이라 E.class안됨)
length 몇개 만들꺼냐 
arr.getClass().getComponenetType(), size
arr의 배열자체타입 그 배열의 한 항목의 타입이 뭔지 찾는 코드
마지막으로 (E[]) 까지!

-------------------------

링크드리스트와 어레이리스트의 차이 (노트필기)

ArrayList
-장점: 인덱스로 바로 찾아간다. 조회가 빠르다.
-단점: 크기를 늘리기 어렵다. 삽입, 삭제에 시간이 소요된다. (새배열에 기존배열 복사하기 때문) , 가비지 많다

LinkedList 
-data가 입력될 때마다 메모리가 확보되는 방법. 무한으로 확장.
-값과 값이 연결된 형태, 열차처럼.
-node와 node를 연결한다.
- 첫번쨰 노드 = first / 마지막노드 = last
-장점: 데이터 추가, 삭제, 삽입이 쉽다.
-단점: 조회가 느리다. (999번째 찾기위해 0번부터 시작해야함)


--------------------------------------

익숙해져야 이해가 된다.
19,20번 마이프로젝트도 하고
알고리즘에 어레이랑 링크드 단계별로 암기

/////////////////////////////////////

  //ArrayList에서 다룰 <클래스이름>을 받는변수, E = 변수명이나 일반적인 변수명아님
  //E만약 E자리에 다른 클래스 이름이 온다면 E를 쓰던 자리는 다 바꾸어야 한다.

// 제네릭은  E[] arr = new E[100]; 이거 안됨  배열을 뉴로 못만듬

  public E get(int index) {
    if (index < 0 && index >= this.size) {
      return null;
    } else {
      return (E) this.elementData[index]; //타입캐스팅(E)
    }
  }

타입캐스팅은 어떨때 하고 어떨때 안하는 거지?
 //타입캐스팅(E) 실행할 때 저장되는 값의 리턴타입이 결정된다. 
스트링이면 스트링인지 아닌지 컴파일러가 다 검사함.



  // 위는 클래스메서드 = 스태틱메서드. 주어진 파라미터 가지고 일을하는 메서드는 스태틱메서드. 특정 인스턴스변수 쓰지않음.
    // 위의 arraycopy()는 다음 코드와 같다.
    // for (int i = 0; i <arr.length; i++) {
    //   arr[i] = (E) this.elementData[i];
    // }

==========================
 this.elementData = Arrays.copyOf(this.elementData, newSize);

//copyOf () 메서드야
//arrayType에 지정된 배열을 size만큼 만들어라.
//그리고 List배열에 저장죈 주소를 새로 만든 배열에 복사하라.
//마지막으로 새로만든 배열의 주소를 리턴한다,

===========================
알고리즘에 있는 것을 비트캠프프로젝트19-1에 복사할것.,
19-1에 어레이리스트는 비트캠프티쳐와 비교해서 저장할 것.