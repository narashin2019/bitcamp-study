200130 목요일

###어제: io ex04~06 : 보고 복사해오기 

### 이제 데이터를 바이트배열로 다뤄보자 io.ex07=상속의 한계 > 데코레이터 설계패턴 오늘 함.

바이트어레이인풋/아웃풋스트림
https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/ByteArrayInputStream.html

인풋아웃풋스트림이 끝에 붙으면 => 바이너리스트림. 있는 그대로 바이트를 읽고 쓰는. 바이너리파일을다룰때 쓰는 용도

이름만봐도 바이너리 데이터 다루는지 텍스터 다루는지 알 수 있음.

네트워크 통신은 주고받는 건 바이트 배열!


*파일인풋스트림을 상속받은 데이터인풋스트림을 편하게 쓰는 것 처럼
ByteArrayInputStream <- ByteArrayDataInputStream을 만든다.
그러나 다중상속이 되지 않으므로 데이터인풋스트림의 코드를 복제해서 와야 한다.

#Exam0110 OK

#Exam0120

*코드를 읽을 때 독해를 할 줄 알아야 한다. 소리내어 코드의 의미를 번역해서 읽는다.

#Exam0130 한계 해결법


어제: 
버퍼드 인풋스트림: 한바구니를 왕창 퍼서 한개 줌 한개줌 한개줌.. 다 떨어지면 한바구니를 또 왕창퍼옴
버퍼에 한번 담고 담아있는걸 리턴해서 속도가 더빠름.

### io. ex07 & ex06 BufferedInputStream BufferedOutputStream : 문제점

###io ex08: 해결방식 데코레이트패턴 이방식으로 하라 

** 다른 블럭에 부품이 될 수는 있지만, 자기자신에 다른 블록을 붙일 수 없는 애.

** 확장기능을 별개의 클래스로 만들고 다 붙일 건데 같은 유형이어야 한다 = 같은 조상이어야 한다.
자식들은 2종류로 나뉜다. 
다른놈의 부품으로 쓸수있고 다른놈을 부품으로 쓸수있는애
다른놈의 부품만 되는애


데이터인풋스트림과 버퍼드인풋스트림을 리틀비츠 형태로 바꿔보자!


###io ex08 


**설계도 꼭 기억*****
모든부품은 같은 조상을 같는다.

부품 종류는 2개다.
- data processing stream class (=decorator) : 부품이 될수도 다른 부품을 사용할 수도 있다/ 중간에 끼운다 (java.io.FilterInputStream) / 조상클래스가 될 수 있다. 
- data sink stream class 일반 부품: 다른부품에 사용 될 순 있어도 다른 부품을 사용할 순 없다. 

----------------------------------

###io.ex09

a: java패키지
b: 오류
c : selializable
d: serialVersionUID
e: transient

----------
다음진도)
네트워킹 프로그램 : 서버 클라이언트로 바꾸는거




